[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-2e0aaae1b6195c2367325f4f02e2d04e9abb55f0b24a779b69b11b9e10269abc.svg)](https://classroom.github.com/online_ide?assignment_repo_id=15566704&assignment_repo_type=AssignmentRepo)
# SE_Day1
Software Engineering Day1 Assignment

#Part 1: Introduction to Software Engineering

Explain what software engineering is and discuss its importance in the technology industry.

Software engineering involves the orderly application of the principles, methods and tools of engineering for designing, constructing, implementing and sustaining reliable software systems. It has aspects of design, construction, evaluation, implementation, and servicing of a software product.

Significance of software engineering in the technology sector: Software engineering is significant in the technology sector since it provides ways by which we can design and develop different software applications that are useful in running different aspects of life such as communication, business, entertainment, and many more.

Identify and describe at least three key milestones in the evolution of software engineering.

The progress of software engineering can be separated into specific stages of growth that have influenced the subject considerably. Another of the first achievements was the appearance of structured programming in the 1960s, which set the strict discipline to coding by using such elements as loops and conditionals. This approach made the developers write programs that were easier to understand and maintain, and thus the birth of sound software systems. Contingent on the source, the Waterfall model originated in either 1970 or the early 1980s. It Requires software development into a strict waterfall model where every facet such as requirement, design implementation and integration, testing, and deployment all have to be completed before the next phase begins. While this model was not without its drawbacks especially as it relates to change of requirements this model gave a lot of structure as the software being developed became increasingly more complex.

The trend for the 21st century is Agile methodologies which have been introduced after publication of the Agile Manifesto in 2001. This was a new paradigm in the development of software where instead of strict methodologies, people focused on integration, meetings and customer feedback. The issues that Waterfall had in regulating software development in complex environments were solved by other frameworks, including Scrum and Kanban. It moved on to DevOps and the CI/CD methodology that emerged in the 2010s focusing in development and operations integrating automation and faster and more credible delivery of software. These milestones in aggregate contrast then increasingly deterministic, linear stages to more organic and synergistic ways of working that characterise current approaches to software development.

List and briefly explain the phases of the Software Development Life Cycle.

The Software Development Life Cycle otherwise referred to as SDLC is a definite plan of action to follow through in the development of software and the following phases are normally involved. The process commences in the Planning phase, where decisions about the project's aims and objectives, its scope and feasibility are made. This consists of defining initial wants, defining perils, and timing all of which provide the project a fundamental or starting point. After this is the Requirements Analysis where the extent of what is needed to do with the tools is explored deeper, this is an expansion of user stories where it is critical to identify in detail both the ‘what’ and the ‘how’ when specifying what is to be built. The Design phase then derives these from the requirements and presents a design document made up of a system architecture, the system components, the interfaces, and data structures among others in the development of the system that is to follow the coding phase.

Following that is the Implementation (Coding)** phase where the developers write up the code using the design made. It is then followed by the Testing phase whereby the productivity of the software is tested for faults and/or compliance with the specifications laid down. There is no testing done in this phase as the application is already being used by the users but before getting there, the application has been subjected to a number of tests during the Deployment phase. The final stage is the Maintenance phase; the role of which is to guarantee that the software will continue to work effectively and will be capable of addressing issues that may arise after the software is deployed, should also be capable of extending the software if necessary with new additions, changes amongst others. Together, these phases ensure that will ensure that software is done systematically to meet the needs of the users and at the same time will ensure that a team and other stakeholders involved in funding the development process are getting value for their efforts.


Compare and contrast the Waterfall and Agile methodologies. Provide examples of scenarios where each would be appropriate.

The Waterfall and Agile methodologies are two extreme models of organizational development in software construction. The waterfall model is strictly an orderly and continuous process where one phase is followed by another in a sequential manner which includes; planning followed by design then implementation, testing and deployment. This is a rigid model and good for those requirements that will not undergo any change over the project duration. For instance, Waterfall is suitable where requirements of the project are frozen at the project start, whether the project is a government contract, infrastructural systems implementation, or industries such as aerospace and defence. This means that its approach offers facility documentation through comprehensive and discernible processes in a step-by-step manner but it poses a disadvantage in that it is rigid in accommodating new evidence or changes that may be realized during the project.

On the other hand, Agile is another approach to software development that is chiefly based on an iterative and more pliable approach where prime emphasis is given to developing smaller functional products of application in the form of cycles called sprints. It has been designed to involve customers and customers and to work in an environment that stresses flexibility, which it is beneficial when undertaking projects that are known to have evolving requirements or where the major priority is to get fresh software out to the market as urgently as feasible. For this reason, Agile is more applicable in the fluid context that is likely to be experienced in a start-up, web development or any business environment in which innovation is the order of the day, or where change is inevitable. For example, creating an application or an online marketing channel in which the user response and market conditions are likely to fluctuate significantly, could also prove to be useful due to Agile’s direction-switching capacity. Agile is flexible and fast-paced, but heavy on new communication and collaboration compared to Waterfall, though due to iterative structure, there is likely less stress on documentation.


Describe the roles and responsibilities of a Software Developer, a Quality Assurance Engineer, and a Project Manager in a software engineering team.

A Software Developer is a professional who works in a software engineering team and his/her duty is to design, code and implement software applications. All the operations that developers perform also involve the requirements given by the stakeholders and the developers write code and also integrate various systems to ensure that this software functions as required. They also engage in debugging errors and problem solving, tuning and at times handling, databases and UIs. As far as the specialization is concerned, they can work as front-end developers, back-end developers, and full-stack developers.

A QA Engineer and a Project Manager are two other roles that are almost like the tip of the iceberg as far as the project’s success is concerned. QA Engineer has the task of exercising the software to establish flaws and flaws by monitoring flaws and reporting critical failures that may make the software not work as planned. They develop and use test strategies, integrate and apply testing techniques, and coordinate with developers on the quality of the product. On the other hand, the Project Manager is in charge of managing the project and making sure that it is on the right track as far as the scope, time frame and cost are concerned. They facilitate the members of their team, control resources and disseminate information between involved parties to make certain that they are on the same page as far as the duties and goals of the project are concerned. The Project Manager also reports and manages risks and challenges that may occur and which might lead to a successful completion of the project to the client’s satisfaction.


Discuss the importance of Integrated Development Environments (IDEs) and Version Control Systems (VCS) in the software development process. Give examples of each.

Other important features of any software development process are Integrated Development Environments (IDEs) and Version Control Systems (VCS), which play an important role in increasing productivity, engaging all participants in the development work and improving the quality of the source code. **IDEs** are Visual Studio Code, IntelliJ IDEA, or Eclipse where developers have tools to write, edit, debug their code, or even test. Developers require environments as these afford features such as syntax highlighting, code completion, debugging tools, and integration with other tools and are all in a single environment. It makes coding easy to do and minimizes on the chances of making mistakes. On the other hand side, systems like the **Version Control Systems** like Git, Mercurial or Subversion are useful for managing the changes in the codebase. VCS also enables developers to check changes made on a section of code, roll back to a previous version when required, and, if different developers worked on the same code, the code of multiple contributors can easily be merged. For example, Git is utilized in open-source and enterprise projects to work on various features or bugs concurrently to avoid the undesired result of losing considerable work done by the other members. Thus, IDEs and VCS contribute to the successful development of the projects while providing teams with the effectiveness and organization of the code.


What are some common challenges faced by software engineers? Provide strategies to overcome these challenges.

Some of the problems that affect software engineers are;- multiple management of a large code base, requirement volatility, inter-team integration and production of quality work within a limited time. In order to deal with these challenges, engineers can apply measures such as top-down and bottom-up application of modular and scaled software systems, application of Agile methodologies where the requirements may often be changing, and open forms of communication between the engineers involved in the project. Finally, it is possible to focus on continuous integration and automated tests for quality code and also to make code reviews to keep standards high. It also ensures that engineers get to learn about the latest tools and approaches to the issues thus enabling them to get ready to deal with them fully.

Explain the different types of testing (unit, integration, system, and acceptance) and their importance in software quality assurance.

The Quality Assurance of software is an essential component, which is achieved through the process of testing and is conducted at a different level to meet the requirements of the users. **Unit testing** is at the basic level that targets a particular part of the software or certain functions of the software system. In unit testing, the testers work on the independent components of the application for instance functions or methods on their own with the rest of the system. The first one is to make sure that every piece of code that is written does what is intended to do. Unit testing is important in the development phase because the bugs that are found are easier and cheaper to fix. It also assists in ascertaining the proper performance of discrete parts before the system is formed. 
 
 Unit testing is succeeded by **Integration testing** which checks what happens when different part of the software is integrated. In these test cases after developing the individual units are connected and the integration tests are carried out to identify those problems which may be hatched in the process of integration. This is important since subcomponents that normally operate effectively can fail to do so when they are combined. **System testing** follows as it is the rate at which the integrated system is tested against customer-specified requirements to ascertain that all will be met. This is the process of running the total and entire software which has all the integrated components in a setting that is similar to that of a production setup. Last of all, **Acceptance testing** is carried out to verify that the software is suitable for use by an end-user or the client as the case may be for deployment. It sometimes requires the client or end-users to use the software in live conditions. Acceptance testing should be done because it confirms that the software developed meets organizational requirements. All these kinds of testing are important because each of them is used to find different kinds of problems, at different phases of the development, thus making the final product as reliable as possible.


#Part 2: Introduction to AI and Prompt Engineering


Define prompt engineering and discuss its importance in interacting with AI models.

Prompt engineering means creating and fine-tuning input questions, or "prompts," to talk to AI systems  those that use natural language processing (NLP) like GPT. Because AI systems come up with answers based on what you ask them how good and clear your question is has a big impact on how good the answer will be. Prompt engineering is about making these questions in a way that helps the AI give useful, correct, and relevant answers. This might mean adding details asking for information in a certain way, or giving background info to help the AI understand what you want.

You can't ignore how important prompt engineering is when you're dealing with AI systems. Good prompts can make AI-generated answers more on-point and accurate, which makes the whole process work better and get more done. Take content creation, for instance. A well-thought-out prompt can lead to text that makes sense and fits the situation. Or if you're trying to find data or solve problems, it can help the AI focus on the most important information. As more and more industries start using AI knowing how to make good prompts becomes key to getting the most out of these systems making sure they help in real-life situations.



Provide an example of a vague prompt and then improve it by making it clear, specific, and concise. Explain why the improved prompt is more effective.

Vague Prompt: "Tell me about software development."

Improved Prompt: "Describe the main stages of the Software Development Life Cycle (SDLC) and give examples of typical problems that crop up during each stage."

The better prompt works well because it's clear, detailed, and to the point. It spells out what info we need—a breakdown of the main SDLC stages and examples of common issues—leaving no room for confusion about what kind of answer we're after. This level of detail helps the AI come up with a focused and on-topic response that hits the nail on the head for what the user wants to know. By laying out both the content (SDLC stages) and the structure (examples of issues), the improved prompt steers the model in the right direction leading to a more accurate and helpful answer.

